import { normalize } from '../helpers/math.helpers';
export function normalizeDataset(data, minX, maxX, minY, maxY) {
    // For the X axis, we want to normalize it based on its index in the array.
    // For the Y axis, we want to normalize it based on the element's value.
    //
    // X axis is easy: just evenly-space each item in the array.
    // For the Y axis, we first need to find the min and max of our array,
    // and then normalize those values between 0 and 1.
    const boundariesX = { min: 0, max: data.length - 1 };
    const boundariesY = { min: Math.min(...data), max: Math.max(...data) };
    const normalizedData = data.map((point, index) => ({
        x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
        y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
    }));
    // According to the SVG spec, paths with a height/width of `0` can't have
    // linear gradients applied. This means that our lines are invisible when
    // the dataset is flat (eg. [0, 0, 0, 0]).
    //
    // The hacky solution is to apply a very slight offset to the first point of
    // the dataset. As ugly as it is, it's the best solution we can find (there
    // are ways within the SVG spec of changing it, but not without causing
    // breaking changes).
    if (boundariesY.min === boundariesY.max) {
        normalizedData[0].y += 0.0001;
    }
    return normalizedData;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdHJlbmQvdHJlbmQuaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFcEQsTUFBTSxVQUFVLGdCQUFnQixDQUM5QixJQUFjLEVBQ2QsSUFBWSxFQUNaLElBQVksRUFDWixJQUFZLEVBQ1osSUFBWTtJQUVaLDJFQUEyRTtJQUMzRSx3RUFBd0U7SUFDeEUsRUFBRTtJQUNGLDREQUE0RDtJQUM1RCxzRUFBc0U7SUFDdEUsbURBQW1EO0lBQ25ELE1BQU0sV0FBVyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztJQUNyRCxNQUFNLFdBQVcsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBRXZFLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2pELENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO1FBQ2pFLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO0tBQ2xFLENBQUMsQ0FBQyxDQUFDO0lBRUoseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSwwQ0FBMEM7SUFDMUMsRUFBRTtJQUNGLDRFQUE0RTtJQUM1RSwyRUFBMkU7SUFDM0UsdUVBQXVFO0lBQ3ZFLHFCQUFxQjtJQUNyQixJQUFJLFdBQVcsQ0FBQyxHQUFHLEtBQUssV0FBVyxDQUFDLEdBQUcsRUFBRTtRQUN2QyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztLQUMvQjtJQUVELE9BQU8sY0FBYyxDQUFDO0FBQ3hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEYXRhc2V0KFxuICBkYXRhOiBudW1iZXJbXSxcbiAgbWluWDogbnVtYmVyLFxuICBtYXhYOiBudW1iZXIsXG4gIG1pblk6IG51bWJlcixcbiAgbWF4WTogbnVtYmVyLFxuKTogQXJyYXk8eyB4OiBudW1iZXI7IHk6IG51bWJlciB9PiB7XG4gIC8vIEZvciB0aGUgWCBheGlzLCB3ZSB3YW50IHRvIG5vcm1hbGl6ZSBpdCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gdGhlIGFycmF5LlxuICAvLyBGb3IgdGhlIFkgYXhpcywgd2Ugd2FudCB0byBub3JtYWxpemUgaXQgYmFzZWQgb24gdGhlIGVsZW1lbnQncyB2YWx1ZS5cbiAgLy9cbiAgLy8gWCBheGlzIGlzIGVhc3k6IGp1c3QgZXZlbmx5LXNwYWNlIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gIC8vIEZvciB0aGUgWSBheGlzLCB3ZSBmaXJzdCBuZWVkIHRvIGZpbmQgdGhlIG1pbiBhbmQgbWF4IG9mIG91ciBhcnJheSxcbiAgLy8gYW5kIHRoZW4gbm9ybWFsaXplIHRob3NlIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuXG4gIGNvbnN0IGJvdW5kYXJpZXNYID0geyBtaW46IDAsIG1heDogZGF0YS5sZW5ndGggLSAxIH07XG4gIGNvbnN0IGJvdW5kYXJpZXNZID0geyBtaW46IE1hdGgubWluKC4uLmRhdGEpLCBtYXg6IE1hdGgubWF4KC4uLmRhdGEpIH07XG5cbiAgY29uc3Qgbm9ybWFsaXplZERhdGEgPSBkYXRhLm1hcCgocG9pbnQsIGluZGV4KSA9PiAoe1xuICAgIHg6IG5vcm1hbGl6ZShpbmRleCwgYm91bmRhcmllc1gubWluLCBib3VuZGFyaWVzWC5tYXgsIG1pblgsIG1heFgpLFxuICAgIHk6IG5vcm1hbGl6ZShwb2ludCwgYm91bmRhcmllc1kubWluLCBib3VuZGFyaWVzWS5tYXgsIG1pblksIG1heFkpLFxuICB9KSk7XG5cbiAgLy8gQWNjb3JkaW5nIHRvIHRoZSBTVkcgc3BlYywgcGF0aHMgd2l0aCBhIGhlaWdodC93aWR0aCBvZiBgMGAgY2FuJ3QgaGF2ZVxuICAvLyBsaW5lYXIgZ3JhZGllbnRzIGFwcGxpZWQuIFRoaXMgbWVhbnMgdGhhdCBvdXIgbGluZXMgYXJlIGludmlzaWJsZSB3aGVuXG4gIC8vIHRoZSBkYXRhc2V0IGlzIGZsYXQgKGVnLiBbMCwgMCwgMCwgMF0pLlxuICAvL1xuICAvLyBUaGUgaGFja3kgc29sdXRpb24gaXMgdG8gYXBwbHkgYSB2ZXJ5IHNsaWdodCBvZmZzZXQgdG8gdGhlIGZpcnN0IHBvaW50IG9mXG4gIC8vIHRoZSBkYXRhc2V0LiBBcyB1Z2x5IGFzIGl0IGlzLCBpdCdzIHRoZSBiZXN0IHNvbHV0aW9uIHdlIGNhbiBmaW5kICh0aGVyZVxuICAvLyBhcmUgd2F5cyB3aXRoaW4gdGhlIFNWRyBzcGVjIG9mIGNoYW5naW5nIGl0LCBidXQgbm90IHdpdGhvdXQgY2F1c2luZ1xuICAvLyBicmVha2luZyBjaGFuZ2VzKS5cbiAgaWYgKGJvdW5kYXJpZXNZLm1pbiA9PT0gYm91bmRhcmllc1kubWF4KSB7XG4gICAgbm9ybWFsaXplZERhdGFbMF0ueSArPSAwLjAwMDE7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZERhdGE7XG59XG4iXX0=