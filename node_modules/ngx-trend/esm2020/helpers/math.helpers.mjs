/* eslint-disable no-restricted-properties */
/** normalize
 * This lets us translate a value from one scale to another.
 *
 * @param value - Our initial value to translate
 * @param min - the current minimum value possible
 * @param max - the current maximum value possible
 * @param scaleMin - the min value of the scale we're translating to
 * @param scaleMax - the max value of the scale we're translating to
 * @returns the value on its new scale
 */
export function normalize(value, min, max, scaleMin = 0, scaleMax = 1) {
    // If the `min` and `max` are the same value, it means our dataset is flat.
    // For now, let's assume that flat data should be aligned to the bottom.
    if (min === max) {
        return scaleMin;
    }
    return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);
}
/** moveTo
 * the coordinate that lies at a midpoint between 2 lines, based on the radius
 *
 * @param to - Our initial point
 * @param to.x - The x value of our initial point
 * @param to.y - The y value of our initial point
 * @param from - Our final point
 * @param from.x - The x value of our final point
 * @param from.y - The y value of our final point
 * @param radius - The distance away from the final point
 * @returns an object holding the x/y coordinates of the midpoint.
 */
export function moveTo(to, from, radius) {
    const length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
    const unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };
    return {
        x: from.x + unitVector.x * radius,
        y: from.y + unitVector.y * radius,
    };
}
/** getDistanceBetween
 * Simple formula derived from pythagoras to calculate the distance between
 * 2 points on a plane.
 *
 * @param p1 - Our initial point
 * @param p1.x - The x value of our initial point
 * @param p1.y - The y value of our initial point
 * @param p2 - Our final point
 * @param p2.x - The x value of our final point
 * @param p2.y - The y value of our final point
 * @returns the distance between the points.
 */
export const getDistanceBetween = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
/** checkForCollinearPoints
 * Figure out if the midpoint fits perfectly on a line between the two others.
 *
 * @param p1 - Our initial point
 * @param p1.x - The x value of our initial point
 * @param p1.y - The y value of our initial point
 * @param p2 - Our mid-point
 * @param p2.x - The x value of our mid-point
 * @param p2.y - The y value of our mid-point
 * @param p3 - Our final point
 * @param p3.x - The x value of our final point
 * @param p3.y - The y value of our final point
 * @returns whether or not p2 sits on the line between p1 and p3.
 */
export const checkForCollinearPoints = (p1, p2, p3) => (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aC5oZWxwZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9oZWxwZXJzL21hdGguaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2Q0FBNkM7QUFFN0M7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FDdkIsS0FBYSxFQUNiLEdBQVcsRUFDWCxHQUFXLEVBQ1gsUUFBUSxHQUFHLENBQUMsRUFDWixRQUFRLEdBQUcsQ0FBQztJQUVaLDJFQUEyRTtJQUMzRSx3RUFBd0U7SUFDeEUsSUFBSSxHQUFHLEtBQUssR0FBRyxFQUFFO1FBQ2YsT0FBTyxRQUFRLENBQUM7S0FDakI7SUFFRCxPQUFPLFFBQVEsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUN4RSxDQUFDO0FBT0Q7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxNQUFNLFVBQVUsTUFBTSxDQUFDLEVBQVMsRUFBRSxJQUFXLEVBQUUsTUFBYztJQUMzRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRyxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQztJQUVoRixPQUFPO1FBQ0wsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxNQUFNO1FBQ2pDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsTUFBTTtLQUNsQyxDQUFDO0FBQ0osQ0FBQztBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxFQUFTLEVBQUUsRUFBUyxFQUFVLEVBQUUsQ0FDakUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRWpFOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxDQUFDLEVBQVMsRUFBRSxFQUFTLEVBQUUsRUFBUyxFQUFXLEVBQUUsQ0FDbEYsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG4vKiogbm9ybWFsaXplXG4gKiBUaGlzIGxldHMgdXMgdHJhbnNsYXRlIGEgdmFsdWUgZnJvbSBvbmUgc2NhbGUgdG8gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBPdXIgaW5pdGlhbCB2YWx1ZSB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSBtaW4gLSB0aGUgY3VycmVudCBtaW5pbXVtIHZhbHVlIHBvc3NpYmxlXG4gKiBAcGFyYW0gbWF4IC0gdGhlIGN1cnJlbnQgbWF4aW11bSB2YWx1ZSBwb3NzaWJsZVxuICogQHBhcmFtIHNjYWxlTWluIC0gdGhlIG1pbiB2YWx1ZSBvZiB0aGUgc2NhbGUgd2UncmUgdHJhbnNsYXRpbmcgdG9cbiAqIEBwYXJhbSBzY2FsZU1heCAtIHRoZSBtYXggdmFsdWUgb2YgdGhlIHNjYWxlIHdlJ3JlIHRyYW5zbGF0aW5nIHRvXG4gKiBAcmV0dXJucyB0aGUgdmFsdWUgb24gaXRzIG5ldyBzY2FsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKFxuICB2YWx1ZTogbnVtYmVyLFxuICBtaW46IG51bWJlcixcbiAgbWF4OiBudW1iZXIsXG4gIHNjYWxlTWluID0gMCxcbiAgc2NhbGVNYXggPSAxLFxuKTogbnVtYmVyIHtcbiAgLy8gSWYgdGhlIGBtaW5gIGFuZCBgbWF4YCBhcmUgdGhlIHNhbWUgdmFsdWUsIGl0IG1lYW5zIG91ciBkYXRhc2V0IGlzIGZsYXQuXG4gIC8vIEZvciBub3csIGxldCdzIGFzc3VtZSB0aGF0IGZsYXQgZGF0YSBzaG91bGQgYmUgYWxpZ25lZCB0byB0aGUgYm90dG9tLlxuICBpZiAobWluID09PSBtYXgpIHtcbiAgICByZXR1cm4gc2NhbGVNaW47XG4gIH1cblxuICByZXR1cm4gc2NhbGVNaW4gKyAodmFsdWUgLSBtaW4pICogKHNjYWxlTWF4IC0gc2NhbGVNaW4pIC8gKG1heCAtIG1pbik7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9pbnQge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn1cblxuLyoqIG1vdmVUb1xuICogdGhlIGNvb3JkaW5hdGUgdGhhdCBsaWVzIGF0IGEgbWlkcG9pbnQgYmV0d2VlbiAyIGxpbmVzLCBiYXNlZCBvbiB0aGUgcmFkaXVzXG4gKlxuICogQHBhcmFtIHRvIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSB0by54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSB0by55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tIC0gT3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gZnJvbS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gZnJvbS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcmFkaXVzIC0gVGhlIGRpc3RhbmNlIGF3YXkgZnJvbSB0aGUgZmluYWwgcG9pbnRcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBob2xkaW5nIHRoZSB4L3kgY29vcmRpbmF0ZXMgb2YgdGhlIG1pZHBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW92ZVRvKHRvOiBQb2ludCwgZnJvbTogUG9pbnQsIHJhZGl1czogbnVtYmVyKTogUG9pbnQge1xuICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoKHRvLnggLSBmcm9tLngpICogKHRvLnggLSBmcm9tLngpICsgKHRvLnkgLSBmcm9tLnkpICogKHRvLnkgLSBmcm9tLnkpKTtcbiAgY29uc3QgdW5pdFZlY3RvciA9IHsgeDogKHRvLnggLSBmcm9tLngpIC8gbGVuZ3RoLCB5OiAodG8ueSAtIGZyb20ueSkgLyBsZW5ndGggfTtcblxuICByZXR1cm4ge1xuICAgIHg6IGZyb20ueCArIHVuaXRWZWN0b3IueCAqIHJhZGl1cyxcbiAgICB5OiBmcm9tLnkgKyB1bml0VmVjdG9yLnkgKiByYWRpdXMsXG4gIH07XG59XG5cbi8qKiBnZXREaXN0YW5jZUJldHdlZW5cbiAqIFNpbXBsZSBmb3JtdWxhIGRlcml2ZWQgZnJvbSBweXRoYWdvcmFzIHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlblxuICogMiBwb2ludHMgb24gYSBwbGFuZS5cbiAqXG4gKiBAcGFyYW0gcDEgLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAyIC0gT3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDIueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAyLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEByZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXREaXN0YW5jZUJldHdlZW4gPSAocDE6IFBvaW50LCBwMjogUG9pbnQpOiBudW1iZXIgPT5cbiAgTWF0aC5zcXJ0KE1hdGgucG93KHAyLnggLSBwMS54LCAyKSArIE1hdGgucG93KHAyLnkgLSBwMS55LCAyKSk7XG5cbi8qKiBjaGVja0ZvckNvbGxpbmVhclBvaW50c1xuICogRmlndXJlIG91dCBpZiB0aGUgbWlkcG9pbnQgZml0cyBwZXJmZWN0bHkgb24gYSBsaW5lIGJldHdlZW4gdGhlIHR3byBvdGhlcnMuXG4gKlxuICogQHBhcmFtIHAxIC0gT3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMS55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGluaXRpYWwgcG9pbnRcbiAqIEBwYXJhbSBwMiAtIE91ciBtaWQtcG9pbnRcbiAqIEBwYXJhbSBwMi54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIG1pZC1wb2ludFxuICogQHBhcmFtIHAyLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgbWlkLXBvaW50XG4gKiBAcGFyYW0gcDMgLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMy54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDMueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgcDIgc2l0cyBvbiB0aGUgbGluZSBiZXR3ZWVuIHAxIGFuZCBwMy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzID0gKHAxOiBQb2ludCwgcDI6IFBvaW50LCBwMzogUG9pbnQpOiBib29sZWFuID0+XG4gIChwMS55IC0gcDIueSkgKiAocDEueCAtIHAzLngpID09PSAocDEueSAtIHAzLnkpICogKHAxLnggLSBwMi54KTtcbiJdfQ==